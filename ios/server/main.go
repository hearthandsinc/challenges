package main

import (
	"errors"
	"fmt"
	"math/rand"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/render"
)

var (
	hostname = envOrDefault("HOSTNAME", "localhost")
	port     = envOrDefault("PORT", "3000")
)

func main() {
	app := NewApp()

	r := chi.NewRouter()

	r.Use(middleware.Logger)
	r.Use(middleware.Recoverer)
	r.Use(middleware.Timeout(15 * time.Second))
	r.Use(render.SetContentType(render.ContentTypeJSON))
	r.Use(func(next http.Handler) http.Handler {
		fn := func(w http.ResponseWriter, r *http.Request) {
			// 10% chance of unavailable
			if rand.Intn(100) < 10 {
				http.Error(w, "unavailable", http.StatusServiceUnavailable)
				return
			}

			// 10% chance of timeout
			if rand.Intn(100) < 10 {
				<-time.After(10 * time.Second)
				http.Error(w, "timeout", http.StatusGatewayTimeout)
				return
			}

			next.ServeHTTP(w, r)
		}
		return http.HandlerFunc(fn)
	})

	r.Get("/chats", app.GetChats)
	r.Post("/chats/{chatID}/messages", app.PostMessages)
	r.Get("/chats/{chatID}/messages", app.GetMessages)

	addr := fmt.Sprintf("%s:%s", hostname, port)
	fmt.Printf("Starting server on %s\n", addr)
	if err := http.ListenAndServe(addr, r); err != nil {
		panic(fmt.Errorf("failed to start server on %s: %w", addr, err))
	}
}

//
// Entities
//

type Chat struct {
	ID   uint32 `json:"id"`
	Name string `json:"name"`

	messages []*Message // not sent to the clients
}

type Message struct {
	ID     uint32    `json:"id"`
	ChatID uint32    `json:"chat_id"`
	Author string    `json:"author"`
	Text   string    `json:"text"`
	SentAt time.Time `json:"sent_at"`
}

// App is both our controller and our data store. This coupling allows to keep
// the implementation simple.
type App struct {
	mu          sync.RWMutex        // mutex to protect concurrent access
	idempotency map[string]struct{} // store idempotency keys
	chats       []*Chat             // chats & messages database
}

func NewApp() *App {
	now := time.Now()

	// chats contains all the chats, manually indexed by their ID in a slice.
	chats := []*Chat{
		{
			ID:   0,
			Name: "John",
			messages: []*Message{
				{ID: newID(), ChatID: 0, Author: "bot", Text: "Sounds good ðŸ‘", SentAt: now},
			},
		},
		{
			ID:   1,
			Name: "Jessica",
			messages: []*Message{
				{ID: newID(), ChatID: 1, Author: "bot", Text: "How are you!?", SentAt: now.Add(-1 * time.Minute)},
			},
		},
		{
			ID:   2,
			Name: "Matt",
			messages: []*Message{
				{ID: newID(), ChatID: 2, Author: "bot", Text: "ok chat soon :)", SentAt: now.Add(-32 * time.Minute)},
			},
		},
		{
			ID:   3,
			Name: "Sarah",
			messages: []*Message{
				{ID: newID(), ChatID: 3, Author: "bot", Text: "ok talk later!", SentAt: now.Add(-32 * time.Hour)},
			},
		},
	}

	return &App{
		idempotency: map[string]struct{}{},
		chats:       chats,
	}
}

func (a *App) GetChats(w http.ResponseWriter, r *http.Request) {
	a.mu.RLock()
	defer a.mu.RUnlock()

	render.JSON(w, r, a.chats)
}

func (a *App) PostMessages(w http.ResponseWriter, r *http.Request) {
	a.mu.Lock()
	defer a.mu.Unlock()

	ok, err := a.checkIdempotencyKey(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	} else if ok {
		return
	}

	chat, err := a.getChatbyID(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	var message Message
	if err := render.DecodeJSON(r.Body, &message); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	chat.messages = append(chat.messages, &Message{
		ID:     newID(),
		Author: "user",
		Text:   message.Text,
		SentAt: time.Now(),
	})

	a.saveIdempotencyKey(r)
}

func (a *App) GetMessages(w http.ResponseWriter, r *http.Request) {
	a.mu.RLock()
	defer a.mu.RUnlock()

	chat, err := a.getChatbyID(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	render.JSON(w, r, chat.messages)
}

func (a *App) checkIdempotencyKey(r *http.Request) (bool, error) {
	key := r.Header.Get("Idempotency-Key")
	if len(key) == 0 {
		return false, errors.New("missing Idempotency-Key header")
	}

	if _, ok := a.idempotency[key]; ok {
		return true, nil
	}

	return false, nil
}

func (a *App) saveIdempotencyKey(r *http.Request) {
	a.idempotency[r.Header.Get("Idempotency-Key")] = struct{}{}
}

func (a *App) getChatbyID(r *http.Request) (*Chat, error) {
	chatID, err := strconv.ParseUint(chi.URLParam(r, "chatID"), 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid chat ID: %w", err)
	}

	if chatID >= uint64(len(a.chats)) {
		return nil, fmt.Errorf("chat ID %d not found", chatID)
	}

	return a.chats[chatID], nil
}

//
// Helpers
//

// lastID is the last ID generated by newID.
var lastID = uint32(time.Now().Unix())

// newID generates a new ID, unique for the lifetime of this server.
func newID() uint32 {
	return atomic.AddUint32(&lastID, 1)
}

// envOrDefault returns the value of the environment variable at the given key.
// Fallbacks to the given default if the value found is missing or empty.
func envOrDefault(key string, defaultValue string) string {
	if v := strings.TrimSpace(os.Getenv(key)); len(v) > 0 {
		return v
	}
	return defaultValue
}
